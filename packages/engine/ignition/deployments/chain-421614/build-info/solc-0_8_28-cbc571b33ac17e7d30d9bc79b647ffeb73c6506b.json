{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-cbc571b33ac17e7d30d9bc79b647ffeb73c6506b",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/tournament/core/libraries/views/Views.sol": "project/contracts/tournament/core/libraries/views/Views.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [],
      "viaIR": true
    },
    "sources": {
      "project/contracts/tournament/core/libraries/calculations/Calculations.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {TournamentCore} from \"./../../TournamentCore.sol\";\n\nlibrary TournamentCalculations {\n    function calculateExitCost(\n        uint256 initialCoins,\n        uint32 actualStartTime,\n        uint16 exitCostBasePercentBPS,\n        uint16 exitCostCompoundRateBPS,\n        uint32 gameInterval\n    ) internal view returns (uint256) {\n        uint32 currentTime = uint32(block.timestamp);\n\n        uint256 intervalsPassed = (currentTime - actualStartTime) /\n            gameInterval;\n        uint256 baseCost = (initialCoins * exitCostBasePercentBPS) / 10000;\n        uint256 multiplier = 10000 +\n            (exitCostCompoundRateBPS * intervalsPassed);\n        return (baseCost * multiplier) / 10000;\n    }\n\n    function calculateCurrentCoins(\n        uint256 storedCoins,\n        uint32 lastDecayTimestamp,\n        uint256 decayAmount,\n        uint32 gameInterval\n    ) internal view returns (uint256) {\n        // Cast block.timestamp to uint32 for consistent arithmetic\n        uint32 currentTime = uint32(block.timestamp);\n\n        if (currentTime <= lastDecayTimestamp) {\n            return storedCoins;\n        }\n\n        uint256 intervalsPassed = (currentTime - lastDecayTimestamp) /\n            gameInterval;\n        uint256 totalDecay = decayAmount * intervalsPassed;\n        return storedCoins > totalDecay ? storedCoins - totalDecay : 0;\n    }\n\n    function calculateForfeitPenalty(\n        uint256 stakeAmount,\n        uint32 endTime,\n        uint32 duration,\n        uint8 forfeitPenaltyType, // 0 = Fixed, 1 = TimeBased\n        uint8 forfeitMaxPenalty,\n        uint8 forfeitMinPenalty\n    ) internal view returns (uint256) {\n        uint256 penaltyPercent;\n\n        if (\n            forfeitPenaltyType == uint8(TournamentCore.ForfeitPenaltyType.Fixed)\n        ) {\n            // For fixed penalty, apply the minimum penalty\n            penaltyPercent = forfeitMinPenalty;\n        } else {\n            // For time-base penalty, calculate the percentage to apply\n            uint32 currentTime = uint32(block.timestamp);\n\n            uint32 timeRemaining = endTime > currentTime\n                ? endTime - currentTime\n                : 0;\n            penaltyPercent =\n                (uint256(forfeitMaxPenalty) * timeRemaining) /\n                duration;\n\n            if (penaltyPercent < forfeitMinPenalty) {\n                // Clamp to min penalty value in case calculated % is too low\n                penaltyPercent = forfeitMinPenalty;\n            }\n            if (penaltyPercent > forfeitMaxPenalty) {\n                // Clamp to max penalty value in case calculated % is too high\n                penaltyPercent = forfeitMaxPenalty;\n            }\n        }\n        return (stakeAmount * penaltyPercent) / 100;\n    }\n\n    function calculatePrizePerWinner(\n        uint256 totalStaked,\n        uint256 totalForfeitPenalties,\n        uint8 platformFeePercent,\n        uint8 creatorFeePercent,\n        uint256 winnerCount\n    ) internal pure returns (uint256) {\n        if (winnerCount == 0) return 0;\n\n        uint256 totalPrizePool = totalStaked + totalForfeitPenalties;\n        uint256 platformFee = (totalPrizePool * platformFeePercent) / 100;\n        uint256 creatorFee = (totalPrizePool * creatorFeePercent) / 100;\n        uint256 distributionPool = totalPrizePool - platformFee - creatorFee;\n\n        return distributionPool / winnerCount;\n    }\n}\n"
      },
      "project/contracts/tournament/core/libraries/views/Views.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {TournamentCore} from \"./../../TournamentCore.sol\";\nimport {TournamentCalculations} from \"./../calculations/Calculations.sol\";\n\nlibrary TournamentViews {\n    error NotFound();\n\n    function getCurrentCoins(\n        TournamentCore.PlayerResources calldata player,\n        uint256 decayAmount,\n        uint32 gameInterval\n    ) external view returns (uint256) {\n        if (!player.exists) return 0;\n\n        return\n            TournamentCalculations.calculateCurrentCoins(\n                player.coins,\n                player.lastDecayTimestamp,\n                decayAmount,\n                gameInterval\n            );\n    }\n\n    function calculateExitCost(\n        TournamentCore.Status status,\n        TournamentCore.PlayerResources calldata player,\n        uint32 actualStartTime,\n        uint16 exitCostBasePercentBPS,\n        uint16 exitCostCompoundRateBPS,\n        uint32 gameInterval\n    ) external view returns (uint256) {\n        if (status != TournamentCore.Status.Active || !player.exists) return 0;\n\n        return\n            TournamentCalculations.calculateExitCost(\n                player.initialCoins,\n                actualStartTime,\n                exitCostBasePercentBPS,\n                exitCostCompoundRateBPS,\n                gameInterval\n            );\n    }\n\n    function canExit(\n        TournamentCore.Status status,\n        TournamentCore.PlayerResources calldata player,\n        uint256 currentCoins,\n        uint256 exitCost,\n        uint8 exitLivesRequired\n    ) external pure returns (bool) {\n        if (status != TournamentCore.Status.Active) return false;\n        if (player.status != TournamentCore.PlayerStatus.Active) return false;\n        if (!player.exists) return false;\n        if (player.lives < exitLivesRequired) return false;\n        if (player.totalCards != 0) return false;\n        if (currentCoins < exitCost) return false;\n\n        return true;\n    }\n\n    function calculateForfeitPenalty(\n        TournamentCore.PlayerResources calldata player,\n        uint32 endTime,\n        uint32 duration,\n        uint8 forfeitPenaltyType,\n        uint8 forfeitMaxPenalty,\n        uint8 forfeitMinPenalty\n    ) external view returns (uint256) {\n        if (!player.exists) return 0;\n\n        return\n            TournamentCalculations.calculateForfeitPenalty(\n                player.stakeAmount,\n                endTime,\n                duration,\n                forfeitPenaltyType,\n                forfeitMaxPenalty,\n                forfeitMinPenalty\n            );\n    }\n\n    function getCurrentPlayerResources(\n        TournamentCore.PlayerResources memory player,\n        uint256 currentCoins\n    ) external pure returns (TournamentCore.PlayerResources memory) {\n        player.coins = currentCoins;\n        return player;\n    }\n\n    function calculatePrizePerWinner(\n        uint256 totalStaked,\n        uint256 totalForfeitPenalties,\n        uint8 platformFeePercent,\n        uint8 creatorFeePercent,\n        uint256 winnersLength\n    ) external pure returns (uint256) {\n        return\n            TournamentCalculations.calculatePrizePerWinner(\n                totalStaked,\n                totalForfeitPenalties,\n                platformFeePercent,\n                creatorFeePercent,\n                winnersLength\n            );\n    }\n\n    function getExitWindow(\n        uint32 exitWindowStart,\n        uint32 endTime\n    )\n        external\n        view\n        returns (uint32 windowStart, uint32 windowEnd, bool isOpen)\n    {\n        windowStart = exitWindowStart;\n        windowEnd = endTime;\n\n        if (block.timestamp < exitWindowStart) {\n            isOpen = false;\n            return (windowStart, windowEnd, isOpen);\n        }\n\n        isOpen = block.timestamp < endTime;\n    }\n\n    function getCurrentCoinsFromStorage(\n        mapping(address => TournamentCore.PlayerResources) storage players,\n        TournamentCore.Params storage params,\n        address player\n    ) external view returns (uint256) {\n        return\n            TournamentCalculations.calculateCurrentCoins(\n                players[player].coins,\n                players[player].lastDecayTimestamp,\n                params.decayAmount,\n                params.gameInterval\n            );\n    }\n\n    function calculateExitCostFromStorage(\n        mapping(address => TournamentCore.PlayerResources) storage players,\n        TournamentCore.Params storage params,\n        TournamentCore.Status status,\n        uint32 actualStartTime,\n        address player\n    ) external view returns (uint256) {\n        if (status != TournamentCore.Status.Active) return 0;\n        if (!players[player].exists) return 0;\n\n        return\n            TournamentCalculations.calculateExitCost(\n                players[player].initialCoins,\n                actualStartTime,\n                params.exitCostBasePercentBPS,\n                params.exitCostCompoundRateBPS,\n                params.gameInterval\n            );\n    }\n\n    function canExitFromStorage(\n        mapping(address => TournamentCore.PlayerResources) storage players,\n        TournamentCore.Params storage params,\n        TournamentCore.Status status,\n        uint32 actualStartTime,\n        address player\n    ) external view returns (bool) {\n        if (status != TournamentCore.Status.Active) return false;\n\n        TournamentCore.PlayerResources storage playerData = players[player];\n        if (!playerData.exists) return false;\n        if (playerData.status != TournamentCore.PlayerStatus.Active)\n            return false;\n        if (playerData.lives < params.exitLivesRequired) return false;\n        if (playerData.totalCards != 0) return false;\n\n        uint256 currentCoins = TournamentCalculations.calculateCurrentCoins(\n            playerData.coins,\n            playerData.lastDecayTimestamp,\n            params.decayAmount,\n            params.gameInterval\n        );\n\n        uint256 exitCost = TournamentCalculations.calculateExitCost(\n            playerData.initialCoins,\n            actualStartTime,\n            params.exitCostBasePercentBPS,\n            params.exitCostCompoundRateBPS,\n            params.gameInterval\n        );\n\n        return currentCoins >= exitCost;\n    }\n\n    function calculateForfeitPenaltyFromStorage(\n        mapping(address => TournamentCore.PlayerResources) storage players,\n        TournamentCore.Params storage params,\n        uint32 endTime,\n        address player\n    ) external view returns (uint256) {\n        if (!players[player].exists) return 0;\n\n        return\n            TournamentCalculations.calculateForfeitPenalty(\n                players[player].stakeAmount,\n                endTime,\n                params.duration,\n                uint8(params.forfeitPenaltyType),\n                params.forfeitMaxPenalty,\n                params.forfeitMinPenalty\n            );\n    }\n\n    function getCurrentPlayerResourcesFromStorage(\n        mapping(address => TournamentCore.PlayerResources) storage players,\n        TournamentCore.Params storage params,\n        address player\n    ) external view returns (TournamentCore.PlayerResources memory) {\n        if (!players[player].exists) revert NotFound();\n\n        TournamentCore.PlayerResources memory playerData = players[player];\n\n        playerData.coins = TournamentCalculations.calculateCurrentCoins(\n            playerData.coins,\n            playerData.lastDecayTimestamp,\n            params.decayAmount,\n            params.gameInterval\n        );\n\n        return playerData;\n    }\n\n    function getPlayerFromStorage(\n        mapping(address => TournamentCore.PlayerResources) storage players,\n        address player\n    ) external view returns (TournamentCore.PlayerResources memory) {\n        if (!players[player].exists) revert NotFound();\n        return players[player];\n    }\n}\n"
      },
      "project/contracts/tournament/core/TournamentCore.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nlibrary TournamentCore {\n    enum Status {\n        Open,\n        Locked,\n        PendingStart,\n        Active,\n        Ended,\n        Cancelled\n    }\n\n    enum PlayerStatus {\n        Active,\n        Exited,\n        Forfeited,\n        PrizeClaimed,\n        Refunded\n    }\n\n    enum ForfeitPenaltyType {\n        Fixed,\n        TimeBased\n    }\n\n    struct Params {\n        uint32 startTimestamp;\n        uint32 duration;\n        uint32 gameInterval;\n        uint16 minPlayers;\n        uint16 maxPlayers;\n        uint16 startPlayerCount;\n        uint256 startPoolAmount;\n        address stakeToken;\n        uint256 minStake;\n        uint256 maxStake;\n        uint40 coinConversionRate;\n        uint256 decayAmount;\n        uint8 initialLives;\n        uint8 cardsPerType;\n        uint8 exitLivesRequired;\n        uint16 exitCostBasePercentBPS;\n        uint16 exitCostCompoundRateBPS;\n        uint8 creatorFeePercent;\n        uint8 platformFeePercent;\n        bool forfeitAllowed;\n        ForfeitPenaltyType forfeitPenaltyType;\n        uint8 forfeitMaxPenalty;\n        uint8 forfeitMinPenalty;\n        address deckCatalog;\n        uint8[] excludedCardIds;\n        uint256 deckDrawCost;\n        uint256 deckShuffleCost;\n        uint256 deckPeekCost;\n    }\n\n    struct PlayerResources {\n        uint256 initialCoins;\n        uint256 coins;\n        uint256 stakeAmount;\n        uint32 lastDecayTimestamp;\n        uint16 combatCount;\n        uint8 lives;\n        uint8 totalCards;\n        PlayerStatus status;\n        bool exists;\n        bool inCombat;\n    }\n\n    uint32 public constant RECOMMENDED_SECONDS_PER_CARD = 360;\n    uint32 public constant MIN_DURATION = 1200;\n    uint8 public constant MIN_CARDS_PER_TYPE = 1;\n    uint8 public constant MAX_CARDS_PER_TYPE = 10;\n    uint16 public constant MIN_PLAYERS_REQUIRED = 2;\n    uint16 public constant MAX_PLAYERS_LIMIT = 10000;\n    uint32 public constant MIN_GAME_INTERVAL = 60;\n    uint32 public constant MAX_GAME_INTERVAL = 3600;\n    uint8 public constant MAX_CREATOR_FEE_PERCENT = 5;\n    uint8 public constant MAX_PLATFORM_FEE = 5;\n    uint8 public constant MAX_COMBINED_FEE_PERCENT = 10;\n    uint8 public constant MIN_INTERVALS_REQUIRED = 3;\n}\n"
      }
    }
  }
}