{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-2da415b7a6f6e0c23b7b3b0fa278dedee35b512c",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/tournament/infrastructure/deck-catalog/TournamentDeckCatalog.sol": "project/contracts/tournament/infrastructure/deck-catalog/TournamentDeckCatalog.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ],
      "viaIR": true
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "project/contracts/tournament/infrastructure/deck-catalog/TournamentDeckCatalog.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TournamentDeckCatalog is Ownable {\n    enum CardCategory {\n        Instant,\n        Modifier,\n        Combat\n    }\n\n    enum ModifierTrigger {\n        None,\n        OnNextFight,\n        OnNextWin,\n        OnNextLoss\n    }\n\n    enum CombatCard {\n        Rock,\n        Paper,\n        Scissors\n    }\n\n    enum MysteryGrantCard {\n        None,\n        Rock,\n        Paper,\n        Scissors\n    }\n\n    enum Objective {\n        ResourceLives,\n        ResourceCoins,\n        ResourceAll,\n        EliminationCount,\n        BattleRate,\n        WinStreak,\n        LoseStreak,\n        VictoryRate,\n        PerfectRecord,\n        TradeCount,\n        TradeVolume\n    }\n\n    struct CardDefinition {\n        bool exists;\n        bool paused;\n        uint8 cardId;\n        CardCategory category;\n        ModifierTrigger trigger;\n        MysteryGrantCard mysteryGrantCard;\n        uint16 baseWeight;\n        bytes effectData;\n    }\n\n    struct ObjectiveDefinition {\n        uint8 objectiveId;\n        Objective objectiveType;\n        bool exists;\n        bool paused;\n        bytes targetData;\n    }\n\n    uint16 public constant LIVES_MULT_1X = 100;\n    uint16 public constant LIVES_MULT_2X = 200;\n    uint16 public constant LIVES_MULT_3X = 300;\n    uint16 public constant MIN_COINS_MULTIPLIER = 50;\n    uint16 public constant MAX_COINS_MULTIPLIER = 300;\n    uint8 public constant STREAK_TIER_1 = 15;\n    uint8 public constant STREAK_TIER_2 = 25;\n    uint8 public constant STREAK_TIER_3 = 35;\n    uint8 public constant STREAK_TIER_4 = 50;\n    uint8 public constant ELIM_TIER_1 = 25;\n    uint8 public constant ELIM_TIER_2 = 50;\n    uint8 public constant ELIM_TIER_3 = 75;\n    uint8 public constant ELIM_TIER_4 = 100;\n    uint8 public constant MIN_BATTLE_RATE_PCT = 1;\n    uint8 public constant MAX_BATTLE_RATE_PCT = 30;\n    uint8 public constant MIN_VICTORY_RATE_PCT = 70;\n    uint8 public constant MAX_VICTORY_RATE_PCT = 100;\n    uint8 public constant MIN_TRADE_COUNT_PCT = 1;\n    uint8 public constant MAX_TRADE_COUNT_PCT = 30;\n    uint8 public constant MIN_TRADE_VOLUME_PCT = 1;\n    uint8 public constant MAX_TRADE_VOLUME_PCT = 150;\n\n    mapping(uint8 => CardDefinition) private _cards;\n    uint8 public cardCount;\n    uint8[] private _cardIds;\n\n    mapping(uint8 => ObjectiveDefinition) private _objectives;\n    uint8 public objectiveCount;\n    uint8[] private _objectiveIds;\n\n    mapping(CardCategory => uint8[]) private _cardsByCategory;\n    mapping(ModifierTrigger => uint8[]) private _cardsByTrigger;\n    mapping(MysteryGrantCard => uint8[]) private _cardsByResourceType;\n\n    event CardRegistered(\n        uint8 indexed cardId,\n        CardCategory category,\n        ModifierTrigger trigger,\n        MysteryGrantCard mysteryGrantCard,\n        uint16 baseWeight,\n        bytes effectData\n    );\n\n    event ObjectiveRegistered(\n        uint8 indexed objectiveId,\n        Objective objectiveType,\n        bytes targetData\n    );\n\n    event CardPaused(uint8 indexed cardId, uint32 timestamp);\n    event CardUnpaused(uint8 indexed cardId, uint32 timestamp);\n    event ObjectivePaused(uint8 indexed objectiveId, uint32 timestamp);\n    event ObjectiveUnpaused(uint8 indexed objectiveId, uint32 timestamp);\n\n    error CardIdTaken();\n    error CardNotFound();\n    error ObjectiveIdTaken();\n    error ObjectiveNotFound();\n    error InvalidCardCategory();\n    error InvalidModifierTrigger();\n    error InvalidResource();\n    error InvalidCardId();\n    error InvalidObjectiveId();\n    error InvalidBaseWeight();\n    error InvalidEffectData();\n    error CardAlreadyPaused();\n    error CardNotPaused();\n    error ObjectiveAlreadyPaused();\n    error ObjectiveNotPaused();\n    error InvalidObjective();\n    error InvalidTargetData();\n    error InvalidMultiplier();\n    error ExceedsMaxCards();\n    error ExceedsMaxObjectives();\n\n    constructor() Ownable(msg.sender) {}\n\n    modifier onlyExistingCards(uint8 cardId) {\n        if (!_cards[cardId].exists) revert CardNotFound();\n        _;\n    }\n\n    modifier onlyExistingObjectives(uint8 objectiveId) {\n        if (!_objectives[objectiveId].exists) revert ObjectiveNotFound();\n        _;\n    }\n\n    function registerCard(CardDefinition calldata card) external onlyOwner {\n        if (card.cardId == 0) revert InvalidCardId();\n        if (_cards[card.cardId].exists) revert CardIdTaken();\n\n        _validateCardDefinition(card);\n\n        _cards[card.cardId] = CardDefinition({\n            exists: true,\n            paused: false,\n            cardId: card.cardId,\n            category: card.category,\n            trigger: card.trigger,\n            mysteryGrantCard: card.mysteryGrantCard,\n            baseWeight: card.baseWeight,\n            effectData: card.effectData\n        });\n\n        _cardIds.push(card.cardId);\n        unchecked {\n            cardCount++;\n        }\n\n        _cardsByCategory[card.category].push(card.cardId);\n        if (card.category == CardCategory.Modifier) {\n            _cardsByTrigger[card.trigger].push(card.cardId);\n        }\n        if (card.category == CardCategory.Combat) {\n            _cardsByResourceType[card.mysteryGrantCard].push(card.cardId);\n        }\n\n        emit CardRegistered(\n            card.cardId,\n            card.category,\n            card.trigger,\n            card.mysteryGrantCard,\n            card.baseWeight,\n            card.effectData\n        );\n    }\n\n    function registerObjective(\n        ObjectiveDefinition calldata objective\n    ) external onlyOwner {\n        if (objective.objectiveId == 0) revert InvalidObjectiveId();\n        if (_objectives[objective.objectiveId].exists)\n            revert ObjectiveIdTaken();\n\n        _validateObjectiveDefinition(objective);\n\n        _objectives[objective.objectiveId] = ObjectiveDefinition({\n            objectiveId: objective.objectiveId,\n            objectiveType: objective.objectiveType,\n            exists: true,\n            paused: false,\n            targetData: objective.targetData\n        });\n\n        _objectiveIds.push(objective.objectiveId);\n        unchecked {\n            objectiveCount++;\n        }\n\n        emit ObjectiveRegistered(\n            objective.objectiveId,\n            objective.objectiveType,\n            objective.targetData\n        );\n    }\n\n    function pauseCard(uint8 card) external onlyOwner onlyExistingCards(card) {\n        if (_cards[card].paused) revert CardAlreadyPaused();\n        _cards[card].paused = true;\n        emit CardPaused(card, uint32(block.timestamp));\n    }\n\n    function unpauseCard(\n        uint8 cardId\n    ) external onlyOwner onlyExistingCards(cardId) {\n        if (!_cards[cardId].paused) revert CardNotPaused();\n        _cards[cardId].paused = false;\n        emit CardUnpaused(cardId, uint32(block.timestamp));\n    }\n\n    function pauseObjective(\n        uint8 objectiveId\n    ) external onlyOwner onlyExistingObjectives(objectiveId) {\n        if (_objectives[objectiveId].paused) revert ObjectiveAlreadyPaused();\n        _objectives[objectiveId].paused = true;\n        emit ObjectivePaused(objectiveId, uint32(block.timestamp));\n    }\n\n    function unpauseObjective(\n        uint8 objectiveId\n    ) external onlyOwner onlyExistingObjectives(objectiveId) {\n        if (!_objectives[objectiveId].paused) revert ObjectiveNotPaused();\n        _objectives[objectiveId].paused = false;\n        emit ObjectiveUnpaused(objectiveId, uint32(block.timestamp));\n    }\n\n    function getCard(\n        uint8 cardId\n    ) external view onlyExistingCards(cardId) returns (CardDefinition memory) {\n        return _cards[cardId];\n    }\n\n    function getAllCardIds() external view returns (uint8[] memory) {\n        return _cardIds;\n    }\n\n    function getCards(\n        uint8[] calldata cardIds\n    ) external view returns (CardDefinition[] memory cards) {\n        uint256 length = cardIds.length;\n        cards = new CardDefinition[](length);\n\n        for (uint256 i = 0; i < length; ) {\n            CardDefinition storage card = _cards[cardIds[i]];\n            if (!card.exists) revert CardNotFound();\n            cards[i] = card;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function cardExists(uint8 cardId) external view returns (bool) {\n        return _cards[cardId].exists;\n    }\n\n    function isCardActive(uint8 cardId) external view returns (bool) {\n        return _cards[cardId].exists && !_cards[cardId].paused;\n    }\n\n    function isCardPaused(uint8 cardId) external view returns (bool) {\n        return _cards[cardId].paused;\n    }\n\n    function getObjective(\n        uint8 objectiveId\n    )\n        external\n        view\n        onlyExistingObjectives(objectiveId)\n        returns (ObjectiveDefinition memory)\n    {\n        return _objectives[objectiveId];\n    }\n\n    function getAllObjectiveIds() external view returns (uint8[] memory) {\n        return _objectiveIds;\n    }\n\n    function getObjectives(\n        uint8[] calldata objectiveIds\n    ) external view returns (ObjectiveDefinition[] memory objectives) {\n        uint256 length = objectiveIds.length;\n        objectives = new ObjectiveDefinition[](length);\n\n        for (uint256 i = 0; i < length; ) {\n            ObjectiveDefinition storage obj = _objectives[objectiveIds[i]];\n            if (!obj.exists) revert ObjectiveNotFound();\n            objectives[i] = obj;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function objectiveExists(uint8 objectiveId) external view returns (bool) {\n        return _objectives[objectiveId].exists;\n    }\n\n    function isObjectiveActive(uint8 objectiveId) external view returns (bool) {\n        return\n            _objectives[objectiveId].exists && !_objectives[objectiveId].paused;\n    }\n\n    function isObjectivePaused(uint8 objectiveId) external view returns (bool) {\n        return _objectives[objectiveId].paused;\n    }\n\n    function _validateCardDefinition(\n        CardDefinition calldata card\n    ) internal pure {\n        if (card.baseWeight == 0) revert InvalidBaseWeight();\n        if (card.effectData.length == 0) revert InvalidEffectData();\n\n        CardCategory category = card.category;\n        ModifierTrigger trigger = card.trigger;\n        MysteryGrantCard mysteryGrantCard = card.mysteryGrantCard;\n\n        unchecked {\n            // Modifier: trigger != None, mysteryGrantCard == None\n            if (category == CardCategory.Modifier) {\n                if (trigger == ModifierTrigger.None)\n                    revert InvalidModifierTrigger();\n                if (mysteryGrantCard != MysteryGrantCard.None)\n                    revert InvalidResource();\n                return;\n            }\n\n            if (category == CardCategory.Combat) {\n                if (mysteryGrantCard == MysteryGrantCard.None)\n                    revert InvalidResource();\n                if (trigger != ModifierTrigger.None)\n                    revert InvalidModifierTrigger();\n                return;\n            }\n\n            if (category == CardCategory.Instant) {\n                if (trigger != ModifierTrigger.None)\n                    revert InvalidModifierTrigger();\n                if (mysteryGrantCard != MysteryGrantCard.None)\n                    revert InvalidResource();\n                return;\n            }\n\n            revert InvalidCardCategory();\n        }\n    }\n\n    function _validateObjectiveDefinition(\n        ObjectiveDefinition calldata objective\n    ) internal pure {\n        if (objective.targetData.length == 0) revert InvalidTargetData();\n\n        if (objective.objectiveType == Objective.ResourceLives) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n            uint16 multiplier = abi.decode(objective.targetData, (uint16));\n            if (\n                multiplier != LIVES_MULT_1X &&\n                multiplier != LIVES_MULT_2X &&\n                multiplier != LIVES_MULT_3X\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else if (objective.objectiveType == Objective.ResourceCoins) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n            uint16 multiplier = abi.decode(objective.targetData, (uint16));\n            if (\n                multiplier < MIN_COINS_MULTIPLIER ||\n                multiplier > MAX_COINS_MULTIPLIER\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else if (objective.objectiveType == Objective.ResourceAll) {\n            if (objective.targetData.length != 64) revert InvalidTargetData();\n            (uint16 livesMult, uint16 coinsMult) = abi.decode(\n                objective.targetData,\n                (uint16, uint16)\n            );\n\n            if (\n                livesMult != LIVES_MULT_1X &&\n                livesMult != LIVES_MULT_2X &&\n                livesMult != LIVES_MULT_3X\n            ) {\n                revert InvalidMultiplier();\n            }\n\n            if (\n                coinsMult < MIN_COINS_MULTIPLIER ||\n                coinsMult > MAX_COINS_MULTIPLIER\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else if (\n            objective.objectiveType == Objective.WinStreak ||\n            objective.objectiveType == Objective.LoseStreak\n        ) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n            uint8 percentage = abi.decode(objective.targetData, (uint8));\n            if (\n                percentage != STREAK_TIER_1 &&\n                percentage != STREAK_TIER_2 &&\n                percentage != STREAK_TIER_3 &&\n                percentage != STREAK_TIER_4\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else if (objective.objectiveType == Objective.EliminationCount) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n            uint8 percentage = abi.decode(objective.targetData, (uint8));\n            if (\n                percentage != ELIM_TIER_1 &&\n                percentage != ELIM_TIER_2 &&\n                percentage != ELIM_TIER_3 &&\n                percentage != ELIM_TIER_4\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else if (objective.objectiveType == Objective.BattleRate) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n            uint8 percentage = abi.decode(objective.targetData, (uint8));\n            if (\n                percentage < MIN_BATTLE_RATE_PCT ||\n                percentage > MAX_BATTLE_RATE_PCT\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else if (objective.objectiveType == Objective.VictoryRate) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n            uint8 percentage = abi.decode(objective.targetData, (uint8));\n            if (\n                percentage < MIN_VICTORY_RATE_PCT ||\n                percentage > MAX_VICTORY_RATE_PCT\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else if (objective.objectiveType == Objective.PerfectRecord) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n        } else if (objective.objectiveType == Objective.TradeCount) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n            uint8 percentage = abi.decode(objective.targetData, (uint8));\n            if (\n                percentage < MIN_TRADE_COUNT_PCT ||\n                percentage > MAX_TRADE_COUNT_PCT\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else if (objective.objectiveType == Objective.TradeVolume) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n            uint8 percentage = abi.decode(objective.targetData, (uint8));\n            if (\n                percentage < MIN_TRADE_VOLUME_PCT ||\n                percentage > MAX_TRADE_VOLUME_PCT\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else {\n            revert InvalidObjective();\n        }\n    }\n}\n"
      }
    }
  }
}