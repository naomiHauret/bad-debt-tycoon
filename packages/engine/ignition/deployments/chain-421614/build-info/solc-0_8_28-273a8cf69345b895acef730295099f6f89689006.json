{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-273a8cf69345b895acef730295099f6f89689006",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/tournament/modules/trading/TournamentTrading.sol": "project/contracts/tournament/modules/trading/TournamentTrading.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ],
      "viaIR": true
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/proxy/utils/Initializable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n     *\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n     */\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }\n}\n"
      },
      "project/contracts/tournament/core/TournamentCore.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nlibrary TournamentCore {\n    enum Status {\n        Open,\n        Locked,\n        PendingStart,\n        Active,\n        Ended,\n        Cancelled\n    }\n\n    enum PlayerStatus {\n        Active,\n        Exited,\n        Forfeited,\n        PrizeClaimed,\n        Refunded\n    }\n\n    enum ForfeitPenaltyType {\n        Fixed,\n        TimeBased\n    }\n\n    struct Params {\n        uint32 startTimestamp;\n        uint32 duration;\n        uint32 gameInterval;\n        uint16 minPlayers;\n        uint16 maxPlayers;\n        uint16 startPlayerCount;\n        uint256 startPoolAmount;\n        address stakeToken;\n        uint256 minStake;\n        uint256 maxStake;\n        uint40 coinConversionRate;\n        uint256 decayAmount;\n        uint8 initialLives;\n        uint8 cardsPerType;\n        uint8 exitLivesRequired;\n        uint16 exitCostBasePercentBPS;\n        uint16 exitCostCompoundRateBPS;\n        uint8 creatorFeePercent;\n        uint8 platformFeePercent;\n        bool forfeitAllowed;\n        ForfeitPenaltyType forfeitPenaltyType;\n        uint8 forfeitMaxPenalty;\n        uint8 forfeitMinPenalty;\n        address deckCatalog;\n        uint8[] excludedCardIds;\n        uint256 deckDrawCost;\n        uint256 deckShuffleCost;\n        uint256 deckPeekCost;\n    }\n\n    struct PlayerResources {\n        uint256 initialCoins;\n        uint256 coins;\n        uint256 stakeAmount;\n        uint32 lastDecayTimestamp;\n        uint16 combatCount;\n        uint8 lives;\n        uint8 totalCards;\n        PlayerStatus status;\n        bool exists;\n        bool inCombat;\n    }\n\n    uint32 public constant RECOMMENDED_SECONDS_PER_CARD = 360;\n    uint32 public constant MIN_DURATION = 1200;\n    uint8 public constant MIN_CARDS_PER_TYPE = 1;\n    uint8 public constant MAX_CARDS_PER_TYPE = 10;\n    uint16 public constant MIN_PLAYERS_REQUIRED = 2;\n    uint16 public constant MAX_PLAYERS_LIMIT = 10000;\n    uint32 public constant MIN_GAME_INTERVAL = 60;\n    uint32 public constant MAX_GAME_INTERVAL = 3600;\n    uint8 public constant MAX_CREATOR_FEE_PERCENT = 5;\n    uint8 public constant MAX_PLATFORM_FEE = 5;\n    uint8 public constant MAX_COMBINED_FEE_PERCENT = 10;\n    uint8 public constant MIN_INTERVALS_REQUIRED = 3;\n}\n"
      },
      "project/contracts/tournament/modules/trading/TournamentTrading.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {TournamentCore} from \"./../../core/TournamentCore.sol\";\n\ninterface ITournamentHub {\n    function getPlayer(\n        address player\n    ) external view returns (TournamentCore.PlayerResources memory);\n    function updatePlayerResources(\n        address player,\n        TournamentCore.PlayerResources calldata resources\n    ) external;\n    function getParams() external view returns (TournamentCore.Params memory);\n    function status() external view returns (TournamentCore.Status);\n}\n\ncontract TournamentTrading is Initializable {\n    address public hub;\n    address public gameOracle;\n\n    uint256 public nextOfferId;\n    uint256 public totalTradesExecuted;\n\n    enum OfferStatus {\n        Open,\n        Cancelled,\n        Executed\n    }\n\n    struct ResourceBundle {\n        uint8 lives;\n        uint256 coins;\n        uint8 rockCards;\n        uint8 paperCards;\n        uint8 scissorsCards;\n    }\n\n    struct TradeOffer {\n        address creator;\n        uint32 expiresAt;\n        OfferStatus status;\n        bool exists;\n        ResourceBundle offered;\n        ResourceBundle requested;\n    }\n\n    mapping(uint256 => TradeOffer) public offers;\n    mapping(address => uint256[]) private playerOffers;\n\n    event OfferCreated(\n        uint256 indexed offerId,\n        address indexed creator,\n        ResourceBundle offered,\n        ResourceBundle requested,\n        uint32 expiresAt,\n        uint32 createdAt\n    );\n\n    event OfferCancelled(\n        uint256 indexed offerId,\n        address indexed creator,\n        uint32 timestamp\n    );\n\n    event TradeExecuted(\n        uint256 indexed offerId,\n        address indexed creator,\n        address indexed acceptor,\n        uint8 creatorTotalCardsDelta,\n        uint8 acceptorTotalCardsDelta,\n        uint32 timestamp\n    );\n\n    error InvalidAddress();\n    error OnlyGameOracle();\n    error PlayerNotFound();\n    error PlayerNotActive();\n    error PlayerInCombat();\n    error OfferNotFound();\n    error OfferExpired();\n    error OfferNotActive();\n    error NotOfferCreator();\n    error InsufficientResources();\n    error ResourceOverflow();\n    error TournamentNotActive();\n    error InvalidCardDeltas();\n\n    modifier onlyGameOracle() {\n        if (msg.sender != gameOracle) revert OnlyGameOracle();\n        _;\n    }\n\n    modifier onlyActivePlayer() {\n        TournamentCore.PlayerResources memory player = ITournamentHub(hub)\n            .getPlayer(msg.sender);\n        if (!player.exists) revert PlayerNotFound();\n        if (player.status != TournamentCore.PlayerStatus.Active)\n            revert PlayerNotActive();\n        if (player.inCombat) revert PlayerInCombat();\n        _;\n    }\n\n    modifier tournamentActive() {\n        if (ITournamentHub(hub).status() != TournamentCore.Status.Active)\n            revert TournamentNotActive();\n        _;\n    }\n\n    function initialize(\n        address _hub,\n        address _gameOracle\n    ) external initializer {\n        if (_hub == address(0) || _gameOracle == address(0))\n            revert InvalidAddress();\n        hub = _hub;\n        gameOracle = _gameOracle;\n        nextOfferId = 1;\n    }\n\n    function createOffer(\n        ResourceBundle calldata offered,\n        ResourceBundle calldata requested\n    ) external onlyActivePlayer tournamentActive returns (uint256 offerId) {\n        TournamentCore.Params memory params = ITournamentHub(hub).getParams();\n        uint32 expiresAt = uint32(block.timestamp) + params.gameInterval;\n\n        offerId = nextOfferId;\n        unchecked {\n            nextOfferId++;\n        }\n\n        offers[offerId] = TradeOffer({\n            creator: msg.sender,\n            expiresAt: expiresAt,\n            status: OfferStatus.Open,\n            exists: true,\n            offered: offered,\n            requested: requested\n        });\n\n        playerOffers[msg.sender].push(offerId);\n\n        emit OfferCreated(\n            offerId,\n            msg.sender,\n            offered,\n            requested,\n            expiresAt,\n            uint32(block.timestamp)\n        );\n    }\n\n    function cancelOffer(\n        uint256 offerId\n    ) external onlyActivePlayer tournamentActive {\n        TradeOffer storage offer = offers[offerId];\n\n        if (!offer.exists) revert OfferNotFound();\n        if (offer.creator != msg.sender) revert NotOfferCreator();\n        if (offer.status != OfferStatus.Open) revert OfferNotActive();\n\n        offer.status = OfferStatus.Cancelled;\n\n        emit OfferCancelled(offerId, msg.sender, uint32(block.timestamp));\n    }\n\n    function executeTradeResolution(\n        uint256 offerId,\n        address acceptor,\n        uint8 creatorTotalCardsDelta,\n        uint8 acceptorTotalCardsDelta\n    ) external onlyGameOracle tournamentActive {\n        TradeOffer storage offer = offers[offerId];\n\n        if (!offer.exists) revert OfferNotFound();\n        if (offer.status != OfferStatus.Open) revert OfferNotActive();\n        if (block.timestamp >= offer.expiresAt) revert OfferExpired();\n\n        // Validate deltas match bundles\n        uint8 offeredTotal = offer.offered.rockCards +\n            offer.offered.paperCards +\n            offer.offered.scissorsCards;\n        uint8 requestedTotal = offer.requested.rockCards +\n            offer.requested.paperCards +\n            offer.requested.scissorsCards;\n\n        if (\n            creatorTotalCardsDelta != offeredTotal ||\n            acceptorTotalCardsDelta != requestedTotal\n        ) revert InvalidCardDeltas();\n\n        TournamentCore.PlayerResources memory creator = ITournamentHub(hub)\n            .getPlayer(offer.creator);\n        TournamentCore.PlayerResources memory acceptorData = ITournamentHub(hub)\n            .getPlayer(acceptor);\n\n        if (!creator.exists || !acceptorData.exists) revert PlayerNotFound();\n        if (\n            creator.status != TournamentCore.PlayerStatus.Active ||\n            acceptorData.status != TournamentCore.PlayerStatus.Active\n        ) revert PlayerNotActive();\n        if (creator.inCombat || acceptorData.inCombat) revert PlayerInCombat();\n\n        if (creator.lives < offer.offered.lives) revert InsufficientResources();\n        if (creator.coins < offer.offered.coins) revert InsufficientResources();\n        if (creator.totalCards < creatorTotalCardsDelta)\n            revert InsufficientResources();\n\n        if (acceptorData.lives < offer.requested.lives)\n            revert InsufficientResources();\n        if (acceptorData.coins < offer.requested.coins)\n            revert InsufficientResources();\n        if (acceptorData.totalCards < acceptorTotalCardsDelta)\n            revert InsufficientResources();\n\n        // Validate uint8 overflow on additions\n        if (\n            creator.totalCards -\n                creatorTotalCardsDelta +\n                acceptorTotalCardsDelta >\n            type(uint8).max\n        ) revert ResourceOverflow();\n        if (\n            acceptorData.totalCards -\n                acceptorTotalCardsDelta +\n                creatorTotalCardsDelta >\n            type(uint8).max\n        ) revert ResourceOverflow();\n\n        creator.lives = _sub(creator.lives, offer.offered.lives);\n        creator.coins -= offer.offered.coins;\n        creator.totalCards -= creatorTotalCardsDelta;\n\n        creator.lives = _add(creator.lives, offer.requested.lives);\n        creator.coins += offer.requested.coins;\n        creator.totalCards += acceptorTotalCardsDelta;\n\n        acceptorData.lives = _sub(acceptorData.lives, offer.requested.lives);\n        acceptorData.coins -= offer.requested.coins;\n        acceptorData.totalCards -= acceptorTotalCardsDelta;\n\n        acceptorData.lives = _add(acceptorData.lives, offer.offered.lives);\n        acceptorData.coins += offer.offered.coins;\n        acceptorData.totalCards += creatorTotalCardsDelta;\n\n        offer.status = OfferStatus.Executed;\n        unchecked {\n            totalTradesExecuted++;\n        }\n\n        ITournamentHub(hub).updatePlayerResources(offer.creator, creator);\n        ITournamentHub(hub).updatePlayerResources(acceptor, acceptorData);\n\n        emit TradeExecuted(\n            offerId,\n            offer.creator,\n            acceptor,\n            creatorTotalCardsDelta,\n            acceptorTotalCardsDelta,\n            uint32(block.timestamp)\n        );\n    }\n\n    function _sub(uint8 a, uint8 b) internal pure returns (uint8) {\n        return a >= b ? a - b : 0;\n    }\n\n    function _add(uint8 a, uint8 b) internal pure returns (uint8) {\n        uint256 result = uint256(a) + uint256(b);\n        if (result > type(uint8).max) revert ResourceOverflow();\n        return uint8(result);\n    }\n\n    function getOffer(\n        uint256 offerId\n    ) external view returns (TradeOffer memory) {\n        return offers[offerId];\n    }\n\n    function getOfferStatus(\n        uint256 offerId\n    ) external view returns (OfferStatus) {\n        if (!offers[offerId].exists) revert OfferNotFound();\n        return offers[offerId].status;\n    }\n\n    function getPlayerOffers(\n        address player\n    ) external view returns (uint256[] memory) {\n        return playerOffers[player];\n    }\n\n    function isOfferActive(uint256 offerId) external view returns (bool) {\n        TradeOffer memory offer = offers[offerId];\n        return\n            offer.exists &&\n            offer.status == OfferStatus.Open &&\n            block.timestamp < offer.expiresAt;\n    }\n}\n"
      }
    }
  }
}