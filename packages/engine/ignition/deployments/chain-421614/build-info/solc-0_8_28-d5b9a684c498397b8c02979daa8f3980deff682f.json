{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-d5b9a684c498397b8c02979daa8f3980deff682f",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/tournament/modules/mystery-deck/TournamentMysteryDeck.sol": "project/contracts/tournament/modules/mystery-deck/TournamentMysteryDeck.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ],
      "viaIR": true
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/proxy/utils/Initializable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n     *\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n     */\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "project/contracts/tournament/core/TournamentCore.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nlibrary TournamentCore {\n    enum Status {\n        Open,\n        Locked,\n        PendingStart,\n        Active,\n        Ended,\n        Cancelled\n    }\n\n    enum PlayerStatus {\n        Active,\n        Exited,\n        Forfeited,\n        PrizeClaimed,\n        Refunded\n    }\n\n    enum ForfeitPenaltyType {\n        Fixed,\n        TimeBased\n    }\n\n    struct Params {\n        uint32 startTimestamp;\n        uint32 duration;\n        uint32 gameInterval;\n        uint16 minPlayers;\n        uint16 maxPlayers;\n        uint16 startPlayerCount;\n        uint256 startPoolAmount;\n        address stakeToken;\n        uint256 minStake;\n        uint256 maxStake;\n        uint40 coinConversionRate;\n        uint256 decayAmount;\n        uint8 initialLives;\n        uint8 cardsPerType;\n        uint8 exitLivesRequired;\n        uint16 exitCostBasePercentBPS;\n        uint16 exitCostCompoundRateBPS;\n        uint8 creatorFeePercent;\n        uint8 platformFeePercent;\n        bool forfeitAllowed;\n        ForfeitPenaltyType forfeitPenaltyType;\n        uint8 forfeitMaxPenalty;\n        uint8 forfeitMinPenalty;\n        address deckCatalog;\n        uint8[] excludedCardIds;\n        uint256 deckDrawCost;\n        uint256 deckShuffleCost;\n        uint256 deckPeekCost;\n    }\n\n    struct PlayerResources {\n        uint256 initialCoins;\n        uint256 coins;\n        uint256 stakeAmount;\n        uint32 lastDecayTimestamp;\n        uint16 combatCount;\n        uint8 lives;\n        uint8 totalCards;\n        PlayerStatus status;\n        bool exists;\n        bool inCombat;\n    }\n\n    uint32 public constant RECOMMENDED_SECONDS_PER_CARD = 360;\n    uint32 public constant MIN_DURATION = 1200;\n    uint8 public constant MIN_CARDS_PER_TYPE = 1;\n    uint8 public constant MAX_CARDS_PER_TYPE = 10;\n    uint16 public constant MIN_PLAYERS_REQUIRED = 2;\n    uint16 public constant MAX_PLAYERS_LIMIT = 10000;\n    uint32 public constant MIN_GAME_INTERVAL = 60;\n    uint32 public constant MAX_GAME_INTERVAL = 3600;\n    uint8 public constant MAX_CREATOR_FEE_PERCENT = 5;\n    uint8 public constant MAX_PLATFORM_FEE = 5;\n    uint8 public constant MAX_COMBINED_FEE_PERCENT = 10;\n    uint8 public constant MIN_INTERVALS_REQUIRED = 3;\n}\n"
      },
      "project/contracts/tournament/infrastructure/deck-catalog/TournamentDeckCatalog.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TournamentDeckCatalog is Ownable {\n    enum CardCategory {\n        Instant,\n        Modifier,\n        Combat\n    }\n\n    enum ModifierTrigger {\n        None,\n        OnNextFight,\n        OnNextWin,\n        OnNextLoss\n    }\n\n    enum CombatCard {\n        Rock,\n        Paper,\n        Scissors\n    }\n\n    enum MysteryGrantCard {\n        None,\n        Rock,\n        Paper,\n        Scissors\n    }\n\n    enum Objective {\n        ResourceLives,\n        ResourceCoins,\n        ResourceAll,\n        EliminationCount,\n        BattleRate,\n        WinStreak,\n        LoseStreak,\n        VictoryRate,\n        PerfectRecord,\n        TradeCount,\n        TradeVolume\n    }\n\n    struct CardDefinition {\n        bool exists;\n        bool paused;\n        uint8 cardId;\n        CardCategory category;\n        ModifierTrigger trigger;\n        MysteryGrantCard mysteryGrantCard;\n        uint16 baseWeight;\n        bytes effectData;\n    }\n\n    struct ObjectiveDefinition {\n        uint8 objectiveId;\n        Objective objectiveType;\n        bool exists;\n        bool paused;\n        bytes targetData;\n    }\n\n    uint16 public constant LIVES_MULT_1X = 100;\n    uint16 public constant LIVES_MULT_2X = 200;\n    uint16 public constant LIVES_MULT_3X = 300;\n    uint16 public constant MIN_COINS_MULTIPLIER = 50;\n    uint16 public constant MAX_COINS_MULTIPLIER = 300;\n    uint8 public constant STREAK_TIER_1 = 15;\n    uint8 public constant STREAK_TIER_2 = 25;\n    uint8 public constant STREAK_TIER_3 = 35;\n    uint8 public constant STREAK_TIER_4 = 50;\n    uint8 public constant ELIM_TIER_1 = 25;\n    uint8 public constant ELIM_TIER_2 = 50;\n    uint8 public constant ELIM_TIER_3 = 75;\n    uint8 public constant ELIM_TIER_4 = 100;\n    uint8 public constant MIN_BATTLE_RATE_PCT = 1;\n    uint8 public constant MAX_BATTLE_RATE_PCT = 30;\n    uint8 public constant MIN_VICTORY_RATE_PCT = 70;\n    uint8 public constant MAX_VICTORY_RATE_PCT = 100;\n    uint8 public constant MIN_TRADE_COUNT_PCT = 1;\n    uint8 public constant MAX_TRADE_COUNT_PCT = 30;\n    uint8 public constant MIN_TRADE_VOLUME_PCT = 1;\n    uint8 public constant MAX_TRADE_VOLUME_PCT = 150;\n\n    mapping(uint8 => CardDefinition) private _cards;\n    uint8 public cardCount;\n    uint8[] private _cardIds;\n\n    mapping(uint8 => ObjectiveDefinition) private _objectives;\n    uint8 public objectiveCount;\n    uint8[] private _objectiveIds;\n\n    mapping(CardCategory => uint8[]) private _cardsByCategory;\n    mapping(ModifierTrigger => uint8[]) private _cardsByTrigger;\n    mapping(MysteryGrantCard => uint8[]) private _cardsByResourceType;\n\n    event CardRegistered(\n        uint8 indexed cardId,\n        CardCategory category,\n        ModifierTrigger trigger,\n        MysteryGrantCard mysteryGrantCard,\n        uint16 baseWeight,\n        bytes effectData\n    );\n\n    event ObjectiveRegistered(\n        uint8 indexed objectiveId,\n        Objective objectiveType,\n        bytes targetData\n    );\n\n    event CardPaused(uint8 indexed cardId, uint32 timestamp);\n    event CardUnpaused(uint8 indexed cardId, uint32 timestamp);\n    event ObjectivePaused(uint8 indexed objectiveId, uint32 timestamp);\n    event ObjectiveUnpaused(uint8 indexed objectiveId, uint32 timestamp);\n\n    error CardIdTaken();\n    error CardNotFound();\n    error ObjectiveIdTaken();\n    error ObjectiveNotFound();\n    error InvalidCardCategory();\n    error InvalidModifierTrigger();\n    error InvalidResource();\n    error InvalidCardId();\n    error InvalidObjectiveId();\n    error InvalidBaseWeight();\n    error InvalidEffectData();\n    error CardAlreadyPaused();\n    error CardNotPaused();\n    error ObjectiveAlreadyPaused();\n    error ObjectiveNotPaused();\n    error InvalidObjective();\n    error InvalidTargetData();\n    error InvalidMultiplier();\n    error ExceedsMaxCards();\n    error ExceedsMaxObjectives();\n\n    constructor() Ownable(msg.sender) {}\n\n    modifier onlyExistingCards(uint8 cardId) {\n        if (!_cards[cardId].exists) revert CardNotFound();\n        _;\n    }\n\n    modifier onlyExistingObjectives(uint8 objectiveId) {\n        if (!_objectives[objectiveId].exists) revert ObjectiveNotFound();\n        _;\n    }\n\n    function registerCard(CardDefinition calldata card) external onlyOwner {\n        if (card.cardId == 0) revert InvalidCardId();\n        if (_cards[card.cardId].exists) revert CardIdTaken();\n\n        _validateCardDefinition(card);\n\n        _cards[card.cardId] = CardDefinition({\n            exists: true,\n            paused: false,\n            cardId: card.cardId,\n            category: card.category,\n            trigger: card.trigger,\n            mysteryGrantCard: card.mysteryGrantCard,\n            baseWeight: card.baseWeight,\n            effectData: card.effectData\n        });\n\n        _cardIds.push(card.cardId);\n        unchecked {\n            cardCount++;\n        }\n\n        _cardsByCategory[card.category].push(card.cardId);\n        if (card.category == CardCategory.Modifier) {\n            _cardsByTrigger[card.trigger].push(card.cardId);\n        }\n        if (card.category == CardCategory.Combat) {\n            _cardsByResourceType[card.mysteryGrantCard].push(card.cardId);\n        }\n\n        emit CardRegistered(\n            card.cardId,\n            card.category,\n            card.trigger,\n            card.mysteryGrantCard,\n            card.baseWeight,\n            card.effectData\n        );\n    }\n\n    function registerObjective(\n        ObjectiveDefinition calldata objective\n    ) external onlyOwner {\n        if (objective.objectiveId == 0) revert InvalidObjectiveId();\n        if (_objectives[objective.objectiveId].exists)\n            revert ObjectiveIdTaken();\n\n        _validateObjectiveDefinition(objective);\n\n        _objectives[objective.objectiveId] = ObjectiveDefinition({\n            objectiveId: objective.objectiveId,\n            objectiveType: objective.objectiveType,\n            exists: true,\n            paused: false,\n            targetData: objective.targetData\n        });\n\n        _objectiveIds.push(objective.objectiveId);\n        unchecked {\n            objectiveCount++;\n        }\n\n        emit ObjectiveRegistered(\n            objective.objectiveId,\n            objective.objectiveType,\n            objective.targetData\n        );\n    }\n\n    function pauseCard(uint8 card) external onlyOwner onlyExistingCards(card) {\n        if (_cards[card].paused) revert CardAlreadyPaused();\n        _cards[card].paused = true;\n        emit CardPaused(card, uint32(block.timestamp));\n    }\n\n    function unpauseCard(\n        uint8 cardId\n    ) external onlyOwner onlyExistingCards(cardId) {\n        if (!_cards[cardId].paused) revert CardNotPaused();\n        _cards[cardId].paused = false;\n        emit CardUnpaused(cardId, uint32(block.timestamp));\n    }\n\n    function pauseObjective(\n        uint8 objectiveId\n    ) external onlyOwner onlyExistingObjectives(objectiveId) {\n        if (_objectives[objectiveId].paused) revert ObjectiveAlreadyPaused();\n        _objectives[objectiveId].paused = true;\n        emit ObjectivePaused(objectiveId, uint32(block.timestamp));\n    }\n\n    function unpauseObjective(\n        uint8 objectiveId\n    ) external onlyOwner onlyExistingObjectives(objectiveId) {\n        if (!_objectives[objectiveId].paused) revert ObjectiveNotPaused();\n        _objectives[objectiveId].paused = false;\n        emit ObjectiveUnpaused(objectiveId, uint32(block.timestamp));\n    }\n\n    function getCard(\n        uint8 cardId\n    ) external view onlyExistingCards(cardId) returns (CardDefinition memory) {\n        return _cards[cardId];\n    }\n\n    function getAllCardIds() external view returns (uint8[] memory) {\n        return _cardIds;\n    }\n\n    function getCards(\n        uint8[] calldata cardIds\n    ) external view returns (CardDefinition[] memory cards) {\n        uint256 length = cardIds.length;\n        cards = new CardDefinition[](length);\n\n        for (uint256 i = 0; i < length; ) {\n            CardDefinition storage card = _cards[cardIds[i]];\n            if (!card.exists) revert CardNotFound();\n            cards[i] = card;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function cardExists(uint8 cardId) external view returns (bool) {\n        return _cards[cardId].exists;\n    }\n\n    function isCardActive(uint8 cardId) external view returns (bool) {\n        return _cards[cardId].exists && !_cards[cardId].paused;\n    }\n\n    function isCardPaused(uint8 cardId) external view returns (bool) {\n        return _cards[cardId].paused;\n    }\n\n    function getObjective(\n        uint8 objectiveId\n    )\n        external\n        view\n        onlyExistingObjectives(objectiveId)\n        returns (ObjectiveDefinition memory)\n    {\n        return _objectives[objectiveId];\n    }\n\n    function getAllObjectiveIds() external view returns (uint8[] memory) {\n        return _objectiveIds;\n    }\n\n    function getObjectives(\n        uint8[] calldata objectiveIds\n    ) external view returns (ObjectiveDefinition[] memory objectives) {\n        uint256 length = objectiveIds.length;\n        objectives = new ObjectiveDefinition[](length);\n\n        for (uint256 i = 0; i < length; ) {\n            ObjectiveDefinition storage obj = _objectives[objectiveIds[i]];\n            if (!obj.exists) revert ObjectiveNotFound();\n            objectives[i] = obj;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function objectiveExists(uint8 objectiveId) external view returns (bool) {\n        return _objectives[objectiveId].exists;\n    }\n\n    function isObjectiveActive(uint8 objectiveId) external view returns (bool) {\n        return\n            _objectives[objectiveId].exists && !_objectives[objectiveId].paused;\n    }\n\n    function isObjectivePaused(uint8 objectiveId) external view returns (bool) {\n        return _objectives[objectiveId].paused;\n    }\n\n    function _validateCardDefinition(\n        CardDefinition calldata card\n    ) internal pure {\n        if (card.baseWeight == 0) revert InvalidBaseWeight();\n        if (card.effectData.length == 0) revert InvalidEffectData();\n\n        CardCategory category = card.category;\n        ModifierTrigger trigger = card.trigger;\n        MysteryGrantCard mysteryGrantCard = card.mysteryGrantCard;\n\n        unchecked {\n            // Modifier: trigger != None, mysteryGrantCard == None\n            if (category == CardCategory.Modifier) {\n                if (trigger == ModifierTrigger.None)\n                    revert InvalidModifierTrigger();\n                if (mysteryGrantCard != MysteryGrantCard.None)\n                    revert InvalidResource();\n                return;\n            }\n\n            if (category == CardCategory.Combat) {\n                if (mysteryGrantCard == MysteryGrantCard.None)\n                    revert InvalidResource();\n                if (trigger != ModifierTrigger.None)\n                    revert InvalidModifierTrigger();\n                return;\n            }\n\n            if (category == CardCategory.Instant) {\n                if (trigger != ModifierTrigger.None)\n                    revert InvalidModifierTrigger();\n                if (mysteryGrantCard != MysteryGrantCard.None)\n                    revert InvalidResource();\n                return;\n            }\n\n            revert InvalidCardCategory();\n        }\n    }\n\n    function _validateObjectiveDefinition(\n        ObjectiveDefinition calldata objective\n    ) internal pure {\n        if (objective.targetData.length == 0) revert InvalidTargetData();\n\n        if (objective.objectiveType == Objective.ResourceLives) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n            uint16 multiplier = abi.decode(objective.targetData, (uint16));\n            if (\n                multiplier != LIVES_MULT_1X &&\n                multiplier != LIVES_MULT_2X &&\n                multiplier != LIVES_MULT_3X\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else if (objective.objectiveType == Objective.ResourceCoins) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n            uint16 multiplier = abi.decode(objective.targetData, (uint16));\n            if (\n                multiplier < MIN_COINS_MULTIPLIER ||\n                multiplier > MAX_COINS_MULTIPLIER\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else if (objective.objectiveType == Objective.ResourceAll) {\n            if (objective.targetData.length != 64) revert InvalidTargetData();\n            (uint16 livesMult, uint16 coinsMult) = abi.decode(\n                objective.targetData,\n                (uint16, uint16)\n            );\n\n            if (\n                livesMult != LIVES_MULT_1X &&\n                livesMult != LIVES_MULT_2X &&\n                livesMult != LIVES_MULT_3X\n            ) {\n                revert InvalidMultiplier();\n            }\n\n            if (\n                coinsMult < MIN_COINS_MULTIPLIER ||\n                coinsMult > MAX_COINS_MULTIPLIER\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else if (\n            objective.objectiveType == Objective.WinStreak ||\n            objective.objectiveType == Objective.LoseStreak\n        ) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n            uint8 percentage = abi.decode(objective.targetData, (uint8));\n            if (\n                percentage != STREAK_TIER_1 &&\n                percentage != STREAK_TIER_2 &&\n                percentage != STREAK_TIER_3 &&\n                percentage != STREAK_TIER_4\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else if (objective.objectiveType == Objective.EliminationCount) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n            uint8 percentage = abi.decode(objective.targetData, (uint8));\n            if (\n                percentage != ELIM_TIER_1 &&\n                percentage != ELIM_TIER_2 &&\n                percentage != ELIM_TIER_3 &&\n                percentage != ELIM_TIER_4\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else if (objective.objectiveType == Objective.BattleRate) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n            uint8 percentage = abi.decode(objective.targetData, (uint8));\n            if (\n                percentage < MIN_BATTLE_RATE_PCT ||\n                percentage > MAX_BATTLE_RATE_PCT\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else if (objective.objectiveType == Objective.VictoryRate) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n            uint8 percentage = abi.decode(objective.targetData, (uint8));\n            if (\n                percentage < MIN_VICTORY_RATE_PCT ||\n                percentage > MAX_VICTORY_RATE_PCT\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else if (objective.objectiveType == Objective.PerfectRecord) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n        } else if (objective.objectiveType == Objective.TradeCount) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n            uint8 percentage = abi.decode(objective.targetData, (uint8));\n            if (\n                percentage < MIN_TRADE_COUNT_PCT ||\n                percentage > MAX_TRADE_COUNT_PCT\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else if (objective.objectiveType == Objective.TradeVolume) {\n            if (objective.targetData.length != 32) revert InvalidTargetData();\n            uint8 percentage = abi.decode(objective.targetData, (uint8));\n            if (\n                percentage < MIN_TRADE_VOLUME_PCT ||\n                percentage > MAX_TRADE_VOLUME_PCT\n            ) {\n                revert InvalidMultiplier();\n            }\n        } else {\n            revert InvalidObjective();\n        }\n    }\n}\n"
      },
      "project/contracts/tournament/modules/mystery-deck/TournamentMysteryDeck.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {TournamentCore} from \"./../../core/TournamentCore.sol\";\nimport {TournamentDeckCatalog} from \"./../../infrastructure/deck-catalog/TournamentDeckCatalog.sol\";\n\ninterface ITournamentHub {\n    function getPlayer(\n        address player\n    ) external view returns (TournamentCore.PlayerResources memory);\n    function getCurrentPlayerResources(\n        address player\n    ) external view returns (TournamentCore.PlayerResources memory);\n    function updatePlayerResources(\n        address player,\n        TournamentCore.PlayerResources calldata resources\n    ) external;\n    function status() external view returns (TournamentCore.Status);\n}\n\ncontract TournamentMysteryDeck is Initializable {\n    address public hub;\n    uint32 public drawCount;\n    uint32 public shuffleCount;\n    uint32 public lastShuffleTime;\n\n    address public catalog;\n    bool public initialized;\n    address public gameOracle;\n\n    uint256 public initialSize;\n    uint256 public cardsRemaining;\n\n    uint256 public drawCost;\n    uint256 public shuffleCost;\n    uint256 public peekCost;\n\n    uint256 public currentShuffleSeed;\n    bytes32 public backendSecretHash;\n\n    uint8[] public excludedCardIds;\n\n    uint8 public constant MAX_EXCLUDED_CARDS = 50;\n    uint8 public constant MAX_PEEK_CARDS = 5;\n    uint256 public constant ADD_REMOVE_COST_MULTIPLIER = 105;\n\n    event DeckInitialized(\n        uint256 indexed deckSize,\n        uint64 indexed sequenceNumber,\n        uint32 timestamp\n    );\n    event CardDrawn(\n        address indexed player,\n        uint256 costPaid,\n        uint256 newDrawCount,\n        uint256 cardsRemaining,\n        uint32 timestamp\n    );\n    event DeckShuffled(\n        address indexed player,\n        uint256 costPaid,\n        uint256 newShuffleCount,\n        uint32 timestamp\n    );\n    event CardsPeeked(\n        address indexed player,\n        uint8 cardCount,\n        uint256 costPaid,\n        uint32 timestamp\n    );\n    event CardsAdded(\n        address indexed player,\n        uint8 cardCount,\n        uint256 costPaid,\n        uint256 newCardsRemaining,\n        uint32 timestamp\n    );\n    event CardsRemoved(\n        address indexed player,\n        uint8 cardCount,\n        uint256 costPaid,\n        uint256 newCardsRemaining,\n        uint32 timestamp\n    );\n    event ShuffleSeedUpdated(\n        uint256 indexed newSeed,\n        bytes32 backendSecretHash,\n        uint32 timestamp\n    );\n\n    error InvalidAddress();\n    error InvalidCost();\n    error TooManyExcludedCards();\n    error DeckAlreadyInitialized();\n    error DeckNotInitialized();\n    error InsufficientCoins();\n    error NotEnoughCardsRemaining();\n    error InvalidPeekCount();\n    error OnlyHub();\n    error OnlyGameOracle();\n    error PlayerNotFound();\n    error PlayerNotActive();\n    error PlayerInCombat();\n    error InvalidCount();\n    error TournamentNotActive();\n    error ResourceOverflow();\n\n    modifier onlyHub() {\n        if (msg.sender != hub) revert OnlyHub();\n        _;\n    }\n\n    modifier onlyGameOracle() {\n        if (msg.sender != gameOracle) revert OnlyGameOracle();\n        _;\n    }\n\n    modifier deckInitialized() {\n        if (!initialized) revert DeckNotInitialized();\n        _;\n    }\n\n    modifier tournamentActive() {\n        if (ITournamentHub(hub).status() != TournamentCore.Status.Active)\n            revert TournamentNotActive();\n        _;\n    }\n\n    modifier onlyActivePlayer() {\n        TournamentCore.PlayerResources memory player = ITournamentHub(hub)\n            .getPlayer(msg.sender);\n        if (!player.exists) revert PlayerNotFound();\n        if (player.status != TournamentCore.PlayerStatus.Active)\n            revert PlayerNotActive();\n        if (player.inCombat) revert PlayerInCombat();\n        _;\n    }\n\n    function initialize(\n        address _hub,\n        address _catalog,\n        uint8[] calldata _excludedCards,\n        uint256 _drawCost,\n        uint256 _shuffleCost,\n        uint256 _peekCost,\n        address _gameOracle\n    ) external initializer {\n        if (\n            _hub == address(0) ||\n            _catalog == address(0) ||\n            _gameOracle == address(0)\n        ) {\n            revert InvalidAddress();\n        }\n\n        if (_drawCost == 0 || _shuffleCost == 0 || _peekCost == 0) {\n            revert InvalidCost();\n        }\n\n        if (_excludedCards.length > MAX_EXCLUDED_CARDS) {\n            revert TooManyExcludedCards();\n        }\n\n        hub = _hub;\n        catalog = _catalog;\n        gameOracle = _gameOracle;\n\n        drawCost = _drawCost;\n        shuffleCost = _shuffleCost;\n        peekCost = _peekCost;\n\n        excludedCardIds = _excludedCards;\n    }\n\n    function initializeDeck() external onlyHub {\n        if (initialized) revert DeckAlreadyInitialized();\n\n        uint8[] memory allCardIds = TournamentDeckCatalog(catalog)\n            .getAllCardIds();\n        uint256 deckSize = _calculateDeckSize(allCardIds) * 50;\n\n        uint64 sequenceNumber = uint64(block.number);\n\n        initialSize = deckSize;\n        cardsRemaining = deckSize;\n        lastShuffleTime = uint32(block.timestamp);\n        initialized = true;\n\n        emit DeckInitialized(deckSize, sequenceNumber, uint32(block.timestamp));\n    }\n\n    function drawCard()\n        external\n        deckInitialized\n        tournamentActive\n        onlyActivePlayer\n    {\n        if (cardsRemaining == 0) revert NotEnoughCardsRemaining();\n\n        address hubCache = hub;\n        TournamentCore.PlayerResources memory player = ITournamentHub(hubCache)\n            .getCurrentPlayerResources(msg.sender);\n\n        if (player.coins < drawCost) revert InsufficientCoins();\n\n        unchecked {\n            player.coins -= drawCost;\n            cardsRemaining--;\n            drawCount++;\n        }\n\n        ITournamentHub(hubCache).updatePlayerResources(msg.sender, player);\n        emit CardDrawn(\n            msg.sender,\n            drawCost,\n            drawCount,\n            cardsRemaining,\n            uint32(block.timestamp)\n        );\n    }\n\n    function shuffleDeck()\n        external\n        deckInitialized\n        tournamentActive\n        onlyActivePlayer\n    {\n        if (cardsRemaining == 0) revert NotEnoughCardsRemaining();\n\n        address hubCache = hub;\n        uint256 costCache = shuffleCost;\n\n        TournamentCore.PlayerResources memory player = ITournamentHub(hubCache)\n            .getCurrentPlayerResources(msg.sender);\n\n        if (player.coins < costCache) revert InsufficientCoins();\n\n        uint32 timestamp = uint32(block.timestamp);\n        unchecked {\n            player.coins -= costCache;\n            shuffleCount++;\n        }\n        lastShuffleTime = timestamp;\n\n        ITournamentHub(hubCache).updatePlayerResources(msg.sender, player);\n        emit DeckShuffled(msg.sender, costCache, shuffleCount, timestamp);\n    }\n\n    function peekCards(\n        uint8 count\n    ) external deckInitialized tournamentActive onlyActivePlayer {\n        if (count == 0 || count > MAX_PEEK_CARDS) revert InvalidPeekCount();\n        if (cardsRemaining < count) revert NotEnoughCardsRemaining();\n\n        address hubCache = hub;\n        uint256 totalCost = peekCost * count;\n\n        TournamentCore.PlayerResources memory player = ITournamentHub(hubCache)\n            .getCurrentPlayerResources(msg.sender);\n\n        if (player.coins < totalCost) revert InsufficientCoins();\n\n        unchecked {\n            player.coins -= totalCost;\n        }\n\n        ITournamentHub(hubCache).updatePlayerResources(msg.sender, player);\n        emit CardsPeeked(msg.sender, count, totalCost, uint32(block.timestamp));\n    }\n\n    function addCards(\n        uint8 count\n    ) external deckInitialized tournamentActive onlyActivePlayer {\n        if (count == 0) revert InvalidCount();\n        if (cardsRemaining + count < cardsRemaining) revert ResourceOverflow();\n\n        address hubCache = hub;\n        uint256 totalCost = (drawCost * ADD_REMOVE_COST_MULTIPLIER * count) /\n            100;\n\n        TournamentCore.PlayerResources memory player = ITournamentHub(hubCache)\n            .getCurrentPlayerResources(msg.sender);\n\n        if (player.coins < totalCost) revert InsufficientCoins();\n\n        uint32 timestamp = uint32(block.timestamp);\n        unchecked {\n            player.coins -= totalCost;\n            cardsRemaining += count;\n        }\n\n        ITournamentHub(hubCache).updatePlayerResources(msg.sender, player);\n        emit CardsAdded(\n            msg.sender,\n            count,\n            totalCost,\n            cardsRemaining,\n            timestamp\n        );\n    }\n\n    function removeCards(\n        uint8 count\n    ) external deckInitialized tournamentActive onlyActivePlayer {\n        if (count == 0) revert InvalidCount();\n        if (cardsRemaining < count) revert NotEnoughCardsRemaining();\n\n        address hubCache = hub;\n        uint256 totalCost = (drawCost * ADD_REMOVE_COST_MULTIPLIER * count) /\n            100;\n\n        TournamentCore.PlayerResources memory player = ITournamentHub(hubCache)\n            .getCurrentPlayerResources(msg.sender);\n\n        if (player.coins < totalCost) revert InsufficientCoins();\n\n        unchecked {\n            player.coins -= totalCost;\n            cardsRemaining -= count;\n        }\n\n        ITournamentHub(hubCache).updatePlayerResources(msg.sender, player);\n        emit CardsRemoved(\n            msg.sender,\n            count,\n            totalCost,\n            cardsRemaining,\n            uint32(block.timestamp)\n        );\n    }\n\n    function updateShuffleSeed(\n        uint256 seed,\n        bytes32 secretHash\n    ) external onlyGameOracle {\n        currentShuffleSeed = seed;\n        backendSecretHash = secretHash;\n\n        emit ShuffleSeedUpdated(seed, secretHash, uint32(block.timestamp));\n    }\n\n    function _calculateDeckSize(\n        uint8[] memory allCardIds\n    ) internal view returns (uint256 size) {\n        uint256 totalCards = allCardIds.length;\n        uint256 excludedCount = excludedCardIds.length;\n\n        if (excludedCount == 0) {\n            return totalCards;\n        }\n\n        for (uint256 i = 0; i < totalCards; ) {\n            bool isExcluded = false;\n\n            for (uint256 j = 0; j < excludedCount; ) {\n                if (allCardIds[i] == excludedCardIds[j]) {\n                    isExcluded = true;\n                    break;\n                }\n                unchecked {\n                    j++;\n                }\n            }\n\n            if (!isExcluded) {\n                unchecked {\n                    size++;\n                }\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function getDeckState()\n        external\n        view\n        returns (\n            uint256 _initialSize,\n            uint256 _cardsRemaining,\n            uint32 _drawCount,\n            uint32 _shuffleCount\n        )\n    {\n        return (initialSize, cardsRemaining, drawCount, shuffleCount);\n    }\n\n    function calculateAddRemoveCost(\n        uint8 count\n    ) external view returns (uint256 cost) {\n        return (drawCost * ADD_REMOVE_COST_MULTIPLIER * count) / 100;\n    }\n}\n"
      }
    }
  }
}